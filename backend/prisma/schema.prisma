// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String    @id @default(cuid())
  email                 String    @unique
  emailVerified         DateTime?
  name                  String?
  image                 String?
  subscription          String    @default("free") // 'free' | 'pro'
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  correctionsCount      Int       @default(0)

  // Relations
  accounts              Account[]
  sessions              Session[]
  searches              Search[]
  corrections           Correction[]
  trackedOpportunities  TrackedOpportunity[]
  outcomes              Outcome[]

  @@index([email])
}

// NextAuth.js Models
model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Video {
  id          String   @id @default(cuid())
  youtubeId   String   @unique
  title       String
  description  String?
  transcript   String?
  thumbnailUrl String
  publishedAt DateTime
  views          Int?
  viewsUpdatedAt DateTime?  // When views were last refreshed from YouTube API
  channelId      String?    // YouTube channel ID
  extractedAt    DateTime?
  labeledAt      DateTime?  // When this video was manually verified/labeled
  labeledBy      String?    // Admin who labeled it

  videoIngredients VideoIngredient[]
  corrections      Correction[]
  videoTags        VideoTag[]

  @@index([youtubeId])
  @@index([publishedAt])
  @@index([labeledAt])
  @@index([viewsUpdatedAt])
  // Full-text search index will be added via SQL migration
}

model VideoTag {
  id         String @id @default(cuid())
  videoId    String
  tag        String   // e.g., "air fryer", "vegan", "korean"
  category   String   // 'cooking_method' | 'dietary' | 'cuisine'
  confidence Float    // 0-1

  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([videoId, tag])
  @@index([videoId])
  @@index([tag])
  @@index([category])
}

model Ingredient {
  id        String   @id @default(cuid())
  name      String   @unique // normalized name (e.g., "tomato")
  createdAt DateTime @default(now())

  videoIngredients VideoIngredient[]
  corrections      Correction[]
  trends           IngredientTrend[]
  synonyms         IngredientSynonym[]

  @@index([name])
}

// Stores ingredient synonyms/aliases for autocomplete and normalization
model IngredientSynonym {
  id           String     @id @default(cuid())
  ingredientId String
  synonym      String     // e.g., "chickens", "chiken" for "chicken"
  source       String     @default("manual") // 'manual' | 'wikidata' | 'user'
  createdAt    DateTime   @default(now())

  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  @@unique([ingredientId, synonym])
  @@index([synonym])
  @@index([ingredientId])
}

model VideoIngredient {
  videoId        String
  ingredientId   String
  confidence     Float    // 0-1
  source         String   // 'title' | 'description' | 'transcript'
  correctionsCount Int    @default(0)
  
  video       Video      @relation(fields: [videoId], references: [id], onDelete: Cascade)
  ingredient  Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  
  @@id([videoId, ingredientId])
  @@index([ingredientId, videoId])
  @@index([videoId])
}

model Search {
  id            String   @id @default(cuid())
  userId        String?
  ingredients   String[] // searched ingredients
  resultCount   Int?     // number of videos returned
  hadYouTubeHit Boolean  @default(false) // did this search call YouTube API?
  demandBand    String?  // demand band at time of search
  createdAt     DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([createdAt])
}

model Correction {
  id           String   @id @default(cuid())
  userId       String
  videoId      String
  ingredientId String
  action       String   // 'wrong' | 'right' | 'add' | 'rename'
  suggestedName String?
  createdAt    DateTime @default(now())
  
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  video      Video      @relation(fields: [videoId], references: [id], onDelete: Cascade)
  ingredient Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  
  @@index([videoId, ingredientId])
  @@index([userId])
}

model TrackedOpportunity {
  id              String   @id @default(cuid())
  userId          String
  ingredients     String[]
  status          String   // 'researching' | 'filming' | 'published' | 'abandoned'
  opportunityScore String // 'high' | 'medium' | 'low'
  trackedAt       DateTime @default(now())
  
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  outcomes Outcome[]
  
  @@index([userId, status])
}

model Outcome {
  id                  String   @id @default(cuid())
  trackedOpportunityId String
  userId              String
  videoUrl            String?
  views7day           Int?
  rating              Int?     // 1-5
  reportedAt          DateTime @default(now())
  
  trackedOpportunity TrackedOpportunity @relation(fields: [trackedOpportunityId], references: [id], onDelete: Cascade)
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([trackedOpportunityId])
  @@index([userId])
}

model DemandSignal {
  id              String   @id @default(cuid())
  ingredientKey   String   @unique // sorted, pipe-joined: "chicken|gochujang"
  ingredients     String[]
  demandScore     Int      // 0-100
  demandBand      String   // 'hot' | 'growing' | 'stable' | 'niche' | 'unknown'
  avgViews        Int
  medianViews     Int
  avgViewsPerDay  Int
  videoCount      Int
  contentGapScore Int      // 0-100
  contentGapType  String   // 'underserved' | 'saturated' | 'balanced' | 'emerging'
  confidence      Float    // 0-1
  sampleSize      Int
  calculatedAt    DateTime @default(now())

  // Google Trends integration
  googleTrendsScore     Int?      // 0-100 from Google Trends
  googleTrendsGrowth    Float?    // Week-over-week growth %
  googleTrendsBreakout  Boolean   @default(false)
  googleTrendsFetchedAt DateTime?

  @@index([ingredientKey])
  @@index([demandBand])
  @@index([calculatedAt])
  @@index([googleTrendsBreakout])
}

// ============================================================================
// ML Training & Analytics Models
// ============================================================================

// Tracks ingredient popularity over time for trend analysis
model IngredientTrend {
  id           String     @id @default(cuid())
  ingredientId String
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  period       String     // 'daily' | 'weekly' | 'monthly'
  periodStart  DateTime   // Start of the period (e.g., 2024-01-15 for daily)
  searchCount  Int        // Number of searches containing this ingredient
  videoCount   Int        // New videos with this ingredient in this period
  avgViews     Int?       // Average views of videos with this ingredient

  @@unique([ingredientId, period, periodStart])
  @@index([period, periodStart])
  @@index([searchCount])
}

// Aggregates correction patterns for extraction improvement
model ExtractionFeedback {
  id           String   @id @default(cuid())
  pattern      String   // Text pattern (e.g., "ethiopian", "chocolate")
  feedbackType String   // 'false_positive' | 'false_negative' | 'rename'
  correctValue String?  // What it should be (null for false positives to block)
  occurrences  Int      @default(1) // How many times this pattern was corrected
  incorporated Boolean  @default(false) // Has this been added to extraction logic?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([pattern, feedbackType])
  @@index([incorporated])
  @@index([feedbackType, occurrences])
}

// Tracks how accurate opportunity predictions have been
model OpportunityCalibration {
  id               String   @id @default(cuid())
  demandBand       String   // 'hot' | 'growing' | 'stable' | 'niche'
  opportunityScore String   // 'high' | 'medium' | 'low'
  totalOutcomes    Int      // Number of outcomes in this bucket
  avgViews7day     Int      // Average 7-day views for this bucket
  avgRating        Float    // Average user rating (1-5)
  successRate      Float    // Percentage with rating >= 4
  calculatedAt     DateTime @default(now())

  @@unique([demandBand, opportunityScore])
  @@index([calculatedAt])
}

// Historical snapshots of extraction accuracy for tracking improvement
model AccuracySnapshot {
  id         String   @id @default(cuid())
  precision  Float    // True positives / (True positives + False positives)
  recall     Float    // True positives / (True positives + False negatives)
  f1         Float    // Harmonic mean of precision and recall
  exactMatch Float    // Percentage with zero errors
  sampleSize Int      // Number of labeled videos used
  measuredAt DateTime @default(now())

  @@index([measuredAt])
}

// ============================================================================
// Google Trends Integration Models
// ============================================================================

// Stores Google Trends interest over time data
model GoogleTrend {
  id            String   @id @default(cuid())
  keyword       String   // ingredient or combination (lowercase)
  interestValue Int      // 0-100 Google Trends score
  isBreakout    Boolean  @default(false) // >5000% growth indicator
  date          DateTime // The date this data point represents
  region        String   @default("worldwide") // Geographic region
  fetchedAt     DateTime @default(now())

  @@unique([keyword, date, region])
  @@index([keyword])
  @@index([date])
  @@index([isBreakout])
  @@index([interestValue])
}

// Stores related/rising queries discovered from Google Trends
model GoogleTrendRelatedQuery {
  id            String   @id @default(cuid())
  parentKeyword String   // The keyword we queried for
  relatedQuery  String   // The suggested related query
  queryType     String   // 'rising' | 'top'
  value         Int?     // For top: 0-100, for rising: growth percentage
  isBreakout    Boolean  @default(false) // >5000% growth
  fetchedAt     DateTime @default(now())

  @@unique([parentKeyword, relatedQuery, fetchedAt])
  @@index([parentKeyword])
  @@index([queryType])
  @@index([isBreakout])
}

// Caches Google Trends API responses to minimize requests
model GoogleTrendsCache {
  id           String   @id @default(cuid())
  cacheKey     String   @unique // Hash of query parameters
  responseData String   @db.Text // JSON stringified response
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@index([cacheKey])
  @@index([expiresAt])
}

// Tracks Google Trends job execution for monitoring
model GoogleTrendsJobLog {
  id           String   @id @default(cuid())
  jobType      String   // 'daily_fetch' | 'discovery' | 'backfill'
  status       String   // 'started' | 'completed' | 'failed'
  keywordCount Int?     // Number of keywords processed
  errorMessage String?  @db.Text
  duration     Int?     // Duration in seconds
  createdAt    DateTime @default(now())

  @@index([createdAt])
  @@index([status])
  @@index([jobType])
}

// ============================================================================
// Ingredient Fetch Job Models
// ============================================================================

// Tracks ingredient fetching jobs from external sources
model IngredientFetchJob {
  id              String   @id @default(cuid())
  source          String   // 'wikidata' | 'openfoodfacts' | 'manual'
  status          String   // 'started' | 'completed' | 'failed'
  newIngredients  Int?     // Number of new ingredients added
  newSynonyms     Int?     // Number of new synonyms added
  skipped         Int?     // Already existing items
  errorMessage    String?  @db.Text
  duration        Int?     // Duration in seconds
  createdAt       DateTime @default(now())

  @@index([createdAt])
  @@index([status])
  @@index([source])
}
